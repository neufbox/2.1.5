diff -pNur linux-2.6.21.7/include/linux/atmdev.h linux-2.6.21.7/include/linux/atmdev.h
--- linux-2.6.21.7/include/linux/atmdev.h	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/include/linux/atmdev.h	2008-06-25 18:34:06.000000000 +0200
@@ -98,10 +98,23 @@ struct atm_dev_stats {
 					/* set backend handler */
 #define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
 					/* use backend to make new if */
+#if 0 // Pavan
 #define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
  					/* add party to p2mp call */
 #define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
 					/* drop party from p2mp call */
+#endif
+#if 1 // Pavan
+#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
+ 					/* add party to p2mp call */
+#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
+					/* drop party from p2mp call */
+#endif
+//#ifdef CONFIG_MIPS_BRCM
+#define ATM_EXTBACKENDIF _IOW('a',ATMIOC_SPECIAL+6,atm_backend_t)
+#define ATM_SETEXTFILT  _IOW('a',ATMIOC_SPECIAL+7,atm_backend_t)
+//#endif
+
 
 /*
  * These are backend handkers that can be set via the ATM_SETBACKEND call
@@ -111,6 +124,13 @@ struct atm_dev_stats {
 #define ATM_BACKEND_RAW		0	
 #define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
 #define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
+//#if defined(CONFIG_MIPS_BRCM)
+#define ATM_BACKEND_RT2684       3  /* Routed RFC1483/2684 */
+#define ATM_BACKEND_BR2684_BCM   4  /* Bridged RFC1483/2684 uses Broadcom ATMAPI*/
+#define ATM_BACKEND_PPP_BCM      5  /* PPPoA uses Broadcom bcmxtmrt driver */
+#define ATM_BACKEND_PPP_BCM_DISCONN    6  /* PPPoA LCP disconnect */
+#define ATM_BACKEND_PPP_BCM_CLOSE_DEV  7  /* PPPoA close device */
+//#endif
 
 /* for ATM_GETTYPE */
 #define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
diff -pNur linux-2.6.21.7/include/linux/atm.h linux-2.6.21.7/include/linux/atm.h
--- linux-2.6.21.7/include/linux/atm.h	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/include/linux/atm.h	2008-06-25 18:34:06.000000000 +0200
@@ -48,6 +48,9 @@
 #define ATM_AAL2	2		/* AAL2 (VBR) */
 #define ATM_AAL34	3		/* AAL3/4 (data) */
 #define ATM_AAL5	5		/* AAL5 (data) */
+#if defined(CONFIG_MIPS_BRCM)
+#define ATM_BCM_AAL0    14              /* "raw" ATM cells */
+#endif
 
 /*
  * socket option name coding functions
diff --exclude=.svn -pNur linux-2.6.21.7/net/atm/br2684.c linux-2.6.21.7/net/atm/br2684.c
--- linux-2.6.21.7/net/atm/br2684.c	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/net/atm/br2684.c	2008-10-13 18:23:39.000000000 +0200
@@ -12,6 +12,7 @@ Author: Marcell GAL, 2000, XDSL Ltd, Hun
 #include <linux/skbuff.h>
 #include <linux/etherdevice.h>
 #include <linux/rtnetlink.h>
+#include <linux/if_vlan.h>
 #include <linux/ip.h>
 #include <asm/uaccess.h>
 #include <net/arp.h>
@@ -23,6 +24,15 @@ Author: Marcell GAL, 2000, XDSL Ltd, Hun
 #include <linux/atmbr2684.h>
 
 #include "common.h"
+#include "ipcommon.h"
+
+#if defined(CONFIG_MIPS_BRCM)
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+typedef unsigned long   UINT32;
+#include <bcmatmapi.h>
+#include <portMirror.h>
+#endif
 
 /*
  * Define this to use a version of the code which interacts with the higher
@@ -33,6 +43,9 @@ Author: Marcell GAL, 2000, XDSL Ltd, Hun
  * if we need space for the header
  */
 /* #define FASTER_VERSION */
+//#define VLAN_DEBUG
+//#define SKB_DEBUG
+
 
 #ifdef DEBUG
 #define DPRINTK(format, args...) printk(KERN_DEBUG "br2684: " format, ##args)
@@ -78,10 +91,35 @@ struct br2684_vcc {
 #ifndef FASTER_VERSION
 	unsigned copies_needed, copies_failed;
 #endif /* FASTER_VERSION */
+#if defined(CONFIG_MIPS_BRCM)
+	/* Protocol filter flag, currently only PPPoE.
+	   When turned on, all non-PPPoE traffic will be dropped
+	   on this PVC */  
+   int proto_filter;
+ 
+	unsigned char *atm_tx_mem;
+	int atm_num_tx_dps;
+	struct list_head atm_list_tx_dps;
+	unsigned long atm_attach_handle;
+
+	int ptm_8023_oam_loopback_mode;
+#endif
 };
 
+#if defined(CONFIG_MIPS_BRCM)
+struct net_devext {
+    struct list_head list;
+    struct net_device net_dev;
+    struct net_device_stats stats;
+    int proto_filter;
+};
+#endif
+
 struct br2684_dev {
 	struct net_device *net_dev;
+#if defined(CONFIG_MIPS_BRCM)
+	struct list_head net_devexts;
+#endif
 	struct list_head br2684_devs;
 	int number;
 	struct list_head brvccs; /* one device <=> one vcc (before xmas) */
@@ -89,6 +127,32 @@ struct br2684_dev {
 	int mac_was_set;
 };
 
+#if defined(CONFIG_MIPS_BRCM)
+static int br2684_attachvcc(struct atm_vcc *atmvcc, void __user *arg);
+static int br2684_start_xmit_bcm(struct sk_buff *skb, struct net_device *dev);
+static void br2684_free_dp( PATM_VCC_DATA_PARMS pDp );
+static void br2684_rx_cb( UINT32 ulHandle, PATM_VCC_ADDR pVccAddr,
+    PATM_VCC_DATA_PARMS pDp, struct br2684_vcc *brvcc );
+static void br2684_free_skb_or_data( PATM_VCC_DATA_PARMS pDp, void *pObj,
+    int nFlag );
+static void br2684_push_bcm(struct atm_vcc *atmvcc, struct sk_buff *skb);
+static int bcm_set_proto_filter(struct atm_vcc *atmvcc, void __user *arg);
+//static int bcm_is_pppoe_passthrough_pkt(struct br2684_dev *brdev, 
+//     struct sk_buff *skb, struct net_device **net_dev);
+static struct net_device *bcm_match_route_interface(struct br2684_dev *brdev, struct sk_buff *skb);
+#endif
+
+#if defined(CONFIG_MIPS_BRCM)
+#define MIN_PKT_SIZE 60
+#endif
+
+#define BR2684_SKB_TAILROOM 16
+
+#define CMP_MAC_ADDR(A1,A2) \
+    (*(unsigned short *) (A1 + 0) == *(unsigned short *) (A2 + 0) && \
+     *(unsigned short *) (A1 + 2) == *(unsigned short *) (A2 + 2) && \
+     *(unsigned short *) (A1 + 4) == *(unsigned short *) (A2 + 4)) ? 1 : 0
+
 /*
  * This lock should be held for writing any time the list of devices or
  * their attached vcc's could be altered.  It should be held for reading
@@ -105,6 +169,18 @@ static inline struct br2684_dev *BRPRIV(
 	return (struct br2684_dev *) net_dev->priv;
 }
 
+#if defined(CONFIG_MIPS_BRCM)
+static inline struct net_devext *EXTPRIV(const struct net_device *net_dev)
+{
+	return (struct net_devext *) net_dev->atalk_ptr;
+}
+
+static inline struct net_device *list_entry_devext(const struct list_head *le)
+{
+	return &(list_entry(le, struct net_devext, list)->net_dev);
+}
+#endif
+
 static inline struct net_device *list_entry_brdev(const struct list_head *le)
 {
 	return list_entry(le, struct br2684_dev, br2684_devs)->net_dev;
@@ -150,9 +226,32 @@ static struct net_device *br2684_find_de
  * otherwise false
  */
 static int br2684_xmit_vcc(struct sk_buff *skb, struct br2684_dev *brdev,
+#if defined(CONFIG_MIPS_BRCM)
+	struct br2684_vcc *brvcc, struct net_device *dev)
+#else
 	struct br2684_vcc *brvcc)
+#endif
 {
 	struct atm_vcc *atmvcc;
+
+#if defined(CONFIG_MIPS_BRCM)
+	struct net_devext *devext = EXTPRIV(dev);
+  
+   /* We pad upto 60 bytes for the data if it is smaller in size */
+    if (skb->len < MIN_PKT_SIZE)
+    {
+       struct sk_buff *skb2=skb_copy_expand(skb, 0, MIN_PKT_SIZE - skb->len, GFP_ATOMIC);
+       dev_kfree_skb(skb);
+       if (skb2 == NULL) {
+          brvcc->copies_failed++;
+          return 0;
+       }
+       skb = skb2;		
+       memset(skb->tail, 0, MIN_PKT_SIZE - skb->len);		
+       skb_put(skb, MIN_PKT_SIZE - skb->len);
+    }
+#endif
+  
 #ifdef FASTER_VERSION
 	if (brvcc->encaps == e_llc)
 		memcpy(skb_push(skb, 8), llc_oui_pid_pad, 8);
@@ -177,7 +276,6 @@ static int br2684_xmit_vcc(struct sk_buf
 	else
 		memset(skb->data, 0, 2);
 #endif /* FASTER_VERSION */
-	skb_debug(skb);
 
 	ATM_SKB(skb)->vcc = atmvcc = brvcc->atmvcc;
 	DPRINTK("atm_skb(%p)->vcc(%p)->dev(%p)\n", skb, atmvcc, atmvcc->dev);
@@ -191,9 +289,31 @@ static int br2684_xmit_vcc(struct sk_buf
 		}
 	atomic_add(skb->truesize, &sk_atm(atmvcc)->sk_wmem_alloc);
 	ATM_SKB(skb)->atm_options = atmvcc->atm_options;
+#if defined(CONFIG_MIPS_BRCM)
+	if (devext) {
+    	    devext->stats.tx_packets++;
+	    devext->stats.tx_bytes += skb->len;	    
+	}
+	else {
+	    brdev->stats.tx_packets++;
+	    brdev->stats.tx_bytes += skb->len;
+	}
+#else
 	brdev->stats.tx_packets++;
 	brdev->stats.tx_bytes += skb->len;
+#endif
+#if defined(CONFIG_MIPS_BRCM)
+	if (atmvcc->send(atmvcc, skb) != 0)
+	{
+	    if (devext)
+		devext->stats.tx_dropped++;
+	    else
+		brdev->stats.tx_dropped++;
+	}
+#else
 	atmvcc->send(atmvcc, skb);
+#endif	
+
 	return 1;
 }
 
@@ -208,20 +328,58 @@ static int br2684_start_xmit(struct sk_b
 {
 	struct br2684_dev *brdev = BRPRIV(dev);
 	struct br2684_vcc *brvcc;
-
+#if defined(CONFIG_MIPS_BRCM)
+	struct net_devext *devext = EXTPRIV(dev);
+#endif
+	
 	DPRINTK("br2684_start_xmit, skb->dst=%p\n", skb->dst);
 	read_lock(&devs_lock);
 	brvcc = pick_outgoing_vcc(skb, brdev);
 	if (brvcc == NULL) {
 		DPRINTK("no vcc attached to dev %s\n", dev->name);
+#if defined(CONFIG_MIPS_BRCM)
+		if (devext) {
+		    devext->stats.tx_errors++;
+		    devext->stats.tx_carrier_errors++;
+		}
+		else {
+		    brdev->stats.tx_errors++;
+		    brdev->stats.tx_carrier_errors++;
+		}
+#else
 		brdev->stats.tx_errors++;
 		brdev->stats.tx_carrier_errors++;
+#endif
+
 		/* netif_stop_queue(dev); */
 		dev_kfree_skb(skb);
 		read_unlock(&devs_lock);
-		return 0;
+		return -EUNATCH;
+	}
+	
+#if defined(CONFIG_MIPS_BRCM)
+/*  trmp fix
+	if (brvcc->proto_filter & FILTER_PPPOE) {
+		if ((skb->protocol != htons(ETH_P_PPP_DISC)) && (skb->protocol != htons(ETH_P_PPP_SES))) {
+			DPRINTK("non-PPPOE packet dropped on TX dev %s\n", dev->name);
+			dev_kfree_skb(skb);
+			read_unlock(&devs_lock);
+			return 0;
+		}
 	}
+*/
+#endif	
+
+#ifdef VLAN_DEBUG
+        if (brvcc->vlan_id != 0xffff)
+                printk("=====> br2684_start_xmit  vlan_id=0x%04x\n", brvcc->vlan_id);
+#endif // VLAN_DEBUG
+
+#if defined(CONFIG_MIPS_BRCM)
+	if (!br2684_xmit_vcc(skb, brdev, brvcc, dev)) {
+#else
 	if (!br2684_xmit_vcc(skb, brdev, brvcc)) {
+#endif
 		/*
 		 * We should probably use netif_*_queue() here, but that
 		 * involves added complication.  We need to walk before
@@ -230,8 +388,19 @@ static int br2684_start_xmit(struct sk_b
 		/* don't free here! this pointer might be no longer valid!
 		dev_kfree_skb(skb);
 		*/
+#if defined(CONFIG_MIPS_BRCM)
+		if (devext) {
+		    devext->stats.tx_errors++;
+		    devext->stats.tx_fifo_errors++;
+		}
+		else {
+		    brdev->stats.tx_errors++;
+		    brdev->stats.tx_fifo_errors++;
+		}
+#else
 		brdev->stats.tx_errors++;
 		brdev->stats.tx_fifo_errors++;
+#endif
 	}
 	read_unlock(&devs_lock);
 	return 0;
@@ -240,7 +409,14 @@ static int br2684_start_xmit(struct sk_b
 static struct net_device_stats *br2684_get_stats(struct net_device *dev)
 {
 	DPRINTK("br2684_get_stats\n");
+#if defined(CONFIG_MIPS_BRCM)
+	if (dev->atalk_ptr)
+	    return &EXTPRIV(dev)->stats;
+	else
+	    return &BRPRIV(dev)->stats;
+#else
 	return &BRPRIV(dev)->stats;
+#endif
 }
 
 #ifdef FASTER_VERSION
@@ -333,9 +509,13 @@ static int (*my_eth_mac_addr)(struct net
 static int br2684_mac_addr(struct net_device *dev, void *p)
 {
 	int err = my_eth_mac_addr(dev, p);
+#if defined(CONFIG_MIPS_BRCM)
+	return err;
+#else
 	if (!err)
 		BRPRIV(dev)->mac_was_set = 1;
 	return err;
+#endif
 }
 
 #ifdef CONFIG_ATM_BR2684_IPFILTER
@@ -395,7 +575,8 @@ static void br2684_close_vcc(struct br26
 	list_del(&brvcc->brvccs);
 	write_unlock_irq(&devs_lock);
 	brvcc->atmvcc->user_back = NULL;	/* what about vcc->recvq ??? */
-	brvcc->old_push(brvcc->atmvcc, NULL);	/* pass on the bad news */
+	if( brvcc->old_push)
+	   brvcc->old_push(brvcc->atmvcc, NULL);	/* pass on the bad news */
 	kfree(brvcc);
 	module_put(THIS_MODULE);
 }
@@ -407,6 +588,12 @@ static void br2684_push(struct atm_vcc *
 	struct net_device *net_dev = brvcc->device;
 	struct br2684_dev *brdev = BRPRIV(net_dev);
 	int plen = sizeof(llc_oui_pid_pad) + ETH_HLEN;
+#if defined(CONFIG_MIPS_BRCM)
+	struct list_head *lh;
+	struct net_device * net_dev_ext;
+	unsigned char *dst;
+	struct sk_buff * skb2;
+#endif
 
 	DPRINTK("br2684_push\n");
 
@@ -422,37 +609,39 @@ static void br2684_push(struct atm_vcc *
 		}
 		return;
 	}
+#if defined(CONFIG_MIPS_BRCM)
+	//skb->__unused=FROM_WAN;
+#endif	
 
-	skb_debug(skb);
 	atm_return(atmvcc, skb->truesize);
 	DPRINTK("skb from brdev %p\n", brdev);
-	if (brvcc->encaps == e_llc) {
-		/* let us waste some time for checking the encapsulation.
-		   Note, that only 7 char is checked so frames with a valid FCS
-		   are also accepted (but FCS is not checked of course) */
-		if (memcmp(skb->data, llc_oui_pid_pad, 7)) {
-			brdev->stats.rx_errors++;
-			dev_kfree_skb(skb);
-			return;
+		if (brvcc->encaps == e_llc) {
+			/* let us waste some time for checking the encapsulation.
+			   Note, that only 7 char is checked so frames with a valid FCS
+			   are also accepted (but FCS is not checked of course) */
+			if (memcmp(skb->data, llc_oui_pid_pad, 7)) {
+				brdev->stats.rx_errors++;
+				dev_kfree_skb(skb);
+				return;
+			}
+
+			/* Strip FCS if present */
+			if (skb->len > 7 && skb->data[7] == 0x01)
+				__skb_trim(skb, skb->len - 4);
+		} else {
+			plen = PADLEN + ETH_HLEN;	/* pad, dstmac,srcmac, ethtype */
+			/* first 2 chars should be 0 */
+			if (*((u16 *) (skb->data)) != 0) {
+				brdev->stats.rx_errors++;
+				dev_kfree_skb(skb);
+				return;
+			}
 		}
-
-		/* Strip FCS if present */
-		if (skb->len > 7 && skb->data[7] == 0x01)
-			__skb_trim(skb, skb->len - 4);
-	} else {
-		plen = PADLEN + ETH_HLEN;	/* pad, dstmac,srcmac, ethtype */
-		/* first 2 chars should be 0 */
-		if (*((u16 *) (skb->data)) != 0) {
+		if (skb->len < plen) {
 			brdev->stats.rx_errors++;
 			dev_kfree_skb(skb);
 			return;
 		}
-	}
-	if (skb->len < plen) {
-		brdev->stats.rx_errors++;
-		dev_kfree_skb(skb);	/* dev_ not needed? */
-		return;
-	}
 
 #ifdef FASTER_VERSION
 	/* FIXME: tcpdump shows that pointer to mac header is 2 bytes earlier,
@@ -476,7 +665,19 @@ static void br2684_push(struct atm_vcc *
 		return;
 	}
 #endif /* CONFIG_ATM_BR2684_IPFILTER */
-	skb->dev = net_dev;
+#if defined(CONFIG_MIPS_BRCM)
+/*  temp fix
+	if (brvcc->proto_filter & FILTER_PPPOE) {
+		if ((skb->protocol != htons(ETH_P_PPP_DISC)) && (skb->protocol != htons(ETH_P_PPP_SES))) {
+			DPRINTK("non-PPPOE packet dropped on RX dev %s\n", net_dev->name);
+			dev_kfree_skb(skb);
+			return;
+		}
+	}
+*/
+#endif
+
+        skb->dev = net_dev;
 	ATM_SKB(skb)->vcc = atmvcc;	/* needed ? */
 	DPRINTK("received packet's protocol: %x\n", ntohs(skb->protocol));
 	skb_debug(skb);
@@ -486,6 +687,7 @@ static void br2684_push(struct atm_vcc *
 		dev_kfree_skb(skb);
 		return;
 	}
+  
 	brdev->stats.rx_packets++;
 	brdev->stats.rx_bytes += skb->len;
 	memset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));
@@ -552,6 +754,9 @@ Note: we do not have explicit unassign, 
 	atmvcc->user_back = brvcc;
 	brvcc->encaps = (enum br2684_encaps) be.encaps;
 	brvcc->old_push = atmvcc->push;
+#if defined(CONFIG_MIPS_BRCM)
+	brvcc->proto_filter |= be.proto_filter;
+#endif	
 	barrier();
 	atmvcc->push = br2684_push;
 
@@ -609,7 +814,7 @@ static void br2684_setup(struct net_devi
 	INIT_LIST_HEAD(&brdev->brvccs);
 }
 
-static int br2684_create(void __user *arg)
+static int br2684_create(void __user *arg, atm_backend_t b)
 {
 	int err;
 	struct net_device *netdev;
@@ -631,8 +836,15 @@ static int br2684_create(void __user *ar
 	if (!netdev)
 		return -ENOMEM;
 
+	if (b == ATM_BACKEND_BR2684_BCM)
+		netdev->hard_start_xmit = br2684_start_xmit_bcm;
+
 	brdev = BRPRIV(netdev);
 
+#if defined(CONFIG_MIPS_BRCM)
+	brdev->net_dev->priv = brdev;
+	INIT_LIST_HEAD(&brdev->net_devexts);
+#endif
 	DPRINTK("registered netdev %s\n", netdev->name);
 	/* open, stop, do_ioctl ? */
 	err = register_netdev(netdev);
@@ -650,6 +862,55 @@ static int br2684_create(void __user *ar
 	return 0;
 }
 
+#if defined(CONFIG_MIPS_BRCM)
+static int br2684_ext(void __user *arg, atm_backend_t b)
+{
+	int err;
+	struct br2684_dev *brdev;
+	struct atm_newif_br2684 ni;
+	struct net_device *net_dev;
+	struct net_devext * net_dev_ext;
+	struct br2684_if_spec s;
+
+	DPRINTK("br2684_ext\n");
+
+	if (copy_from_user(&ni, (void *) arg, sizeof ni)) {
+		return -EFAULT;
+	}
+
+	s.method = BR2684_FIND_BYIFNAME;
+	sprintf(s.spec.ifname, "%s%s", "", ni.ifname); // To pass the link error;
+	net_dev = br2684_find_dev(&s);
+	if (net_dev == NULL) {
+		printk(KERN_ERR
+		    "br2684: tried to attach to non-existant device\n");
+		return -ENXIO;
+	}
+	brdev = BRPRIV(net_dev);
+	brdev->net_dev->priv = brdev;
+	if ((net_dev_ext = kmalloc(sizeof(struct net_devext), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+	memset(net_dev_ext, 0, sizeof(struct net_devext));
+	ether_setup(&net_dev_ext->net_dev);
+	sprintf(net_dev_ext->net_dev.name, "%s_%d", brdev->net_dev->name, ni.media);
+	net_dev_ext->net_dev.atalk_ptr = net_dev_ext;
+	net_dev_ext->net_dev.priv = brdev;
+	net_dev_ext->net_dev.set_mac_address = br2684_mac_addr;
+	if (b == ATM_BACKEND_BR2684_BCM)
+		net_dev_ext->net_dev.hard_start_xmit = br2684_start_xmit_bcm;
+	else
+		net_dev_ext->net_dev.hard_start_xmit = br2684_start_xmit;
+	net_dev_ext->net_dev.get_stats = br2684_get_stats;
+	err = register_netdev(&net_dev_ext->net_dev);
+
+	write_lock_irq(&devs_lock);
+	list_add(&net_dev_ext->list, &brdev->net_devexts);
+	write_unlock_irq(&devs_lock);
+
+	return 0;
+}
+#endif
+
 /*
  * This handles ioctls actually performed on our vcc - we must return
  * -ENOIOCTLCMD for any unrecognized ioctl
@@ -662,27 +923,67 @@ static int br2684_ioctl(struct socket *s
 
 	int err;
 	switch(cmd) {
+#if defined(CONFIG_MIPS_BRCM)
+	case ATM_EXTBACKENDIF:
+        case ATM_SETEXTFILT:
+#endif
 	case ATM_SETBACKEND:
 	case ATM_NEWBACKENDIF: {
 		atm_backend_t b;
 		err = get_user(b, (atm_backend_t __user *) argp);
 		if (err)
+		{
 			return -EFAULT;
-		if (b != ATM_BACKEND_BR2684)
+		}
+		if (b != ATM_BACKEND_BR2684 && b != ATM_BACKEND_BR2684_BCM)
+		{
 			return -ENOIOCTLCMD;
+		}
 		if (!capable(CAP_NET_ADMIN))
+		{
 			return -EPERM;
+		}
+#if defined(CONFIG_MIPS_BRCM)
+		if (cmd == ATM_SETBACKEND)
+		{
+			if( b == ATM_BACKEND_BR2684_BCM)
+			{
+				return br2684_attachvcc(atmvcc, argp);
+			}
+			else
+			{
+				return br2684_regvcc(atmvcc, argp);
+			}
+		}
+		else if (cmd == ATM_NEWBACKENDIF)
+		{
+			return br2684_create(argp, b);
+		}
+		else if (cmd == ATM_EXTBACKENDIF)
+		{
+			return br2684_ext(argp, b);
+		}
+		else
+		{
+			return bcm_set_proto_filter(atmvcc, argp);
+		}
+#else
 		if (cmd == ATM_SETBACKEND)
 			return br2684_regvcc(atmvcc, argp);
 		else
-			return br2684_create(argp);
+			return br2684_create(argp, b);
+#endif
 		}
 #ifdef CONFIG_ATM_BR2684_IPFILTER
 	case BR2684_SETFILT:
 		if (atmvcc->push != br2684_push)
+		{
 			return -ENOIOCTLCMD;
+		}
 		if (!capable(CAP_NET_ADMIN))
+		{
 			return -EPERM;
+		}
 		err = br2684_setfilt(atmvcc, argp);
 		return err;
 #endif /* CONFIG_ATM_BR2684_IPFILTER */
@@ -832,6 +1133,856 @@ static void __exit br2684_exit(void)
 	}
 }
 
+
+#if defined(CONFIG_MIPS_BRCM)
+#define ATM_NUM_RX_SKBS				200
+#define SKB_ALIGNED_SIZE            ((sizeof(struct sk_buff) + 0x0f) & ~0x0f)
+
+extern int rfc2684InMirrorStatus;
+extern int rfc2684OutMirrorStatus;
+extern char mirrorInPort[];
+extern char mirrorOutPort[];
+
+static rwlock_t devs_lock_tx = RW_LOCK_UNLOCKED;
+static unsigned char g_atm_rx_skbs[(ATM_NUM_RX_SKBS * SKB_ALIGNED_SIZE) + 0x10];
+struct sk_buff *g_free_atm_rx_skbs = (struct sk_buff *) -1;
+
+void br2684_mirror_packet( struct sk_buff *pSockBuf, UINT32 dir, char *dev );
+
+/***************************************************************************
+ * Function Name: br2684_attachvcc
+ * Description  : Called by the Linux pvc2684 user mode application to use
+ *                assign a PVC to a network interface.  It initializes data
+ *                structures used by the Broadcom ATM API and calls the
+ *                the Broadcom ATM driver function BcmAtm_AttachVcc to
+ *                reserve use of the PVC.
+ * Returns      : Status.
+ ***************************************************************************/
+static int br2684_attachvcc(struct atm_vcc *atmvcc, void __user *arg)
+{
+    int ret = 0;
+    int i;
+    unsigned char *p;
+    struct br2684_vcc *brvcc;
+    struct sk_buff *skb;
+    struct br2684_dev *brdev;
+    struct net_device *net_dev;
+    struct atm_backend_br2684 be;
+    ATM_VCC_ADDR vcc_addr;
+    ATM_VCC_CFG vcc_cfg;
+    ATM_VCC_ATTACH_PARMS vcc_ap;
+    int atm_tx_mem_size;
+
+    if( copy_from_user(&be, arg, sizeof be) == 0 )
+    {
+        if( (brvcc = kmalloc(sizeof(struct br2684_vcc), GFP_KERNEL)) != NULL )
+        {
+            memset(brvcc, 0, sizeof(struct br2684_vcc));
+            write_lock_irq(&devs_lock);
+            net_dev = br2684_find_dev(&be.ifspec);
+            if( net_dev )
+            {
+                brdev = BRPRIV(net_dev);
+
+                if (list_empty(&brdev->brvccs) && !brdev->mac_was_set)
+                {
+                    /* TBD. How to set MAC address. */
+                    memcpy(net_dev->dev_addr, "\x02\x10\x18\x10\x10\x01", 6);
+                }
+
+                list_add(&brvcc->brvccs, &brdev->brvccs);
+                write_unlock_irq(&devs_lock);
+
+                DPRINTK("br2684_attachvcc 1. vcc=%p, encaps=%d, brvcc=%p, "
+                    "brdev=%p\n", atmvcc, be.encaps, brvcc, brdev);
+
+                brvcc->device = net_dev;
+                brvcc->atmvcc = atmvcc;
+                brvcc->encaps = (enum br2684_encaps) be.encaps;
+                brvcc->proto_filter |= be.proto_filter;
+                brvcc->old_push = atmvcc->push;
+                barrier();
+                atmvcc->push = br2684_push_bcm;
+                atmvcc->dev = atm_dev_lookup(0);
+                atmvcc->user_back = brvcc;
+
+                if( g_free_atm_rx_skbs == (struct sk_buff *) -1 )
+                {
+                    /* Initialize Linux receive socket buffers. */
+                    g_free_atm_rx_skbs = NULL;
+                    for( i = 0, p = (unsigned char *)
+                        (((unsigned long) g_atm_rx_skbs + 0x0f) & ~0x0f);
+                        i < ATM_NUM_RX_SKBS; i++, p += SKB_ALIGNED_SIZE )
+                    {
+                        skb = (struct sk_buff *) p;
+                        skb->retfreeq_context = g_free_atm_rx_skbs;
+                        g_free_atm_rx_skbs = skb;
+                    }
+                }
+
+                /* Allocate and initialize Broadcom ATM API transmit structs. */
+                BcmAtm_GetInterfaceId( (be.has_vpiid >> 28), &vcc_addr.ulInterfaceId );
+                vcc_addr.usVpi = (unsigned short) ((be.has_vpiid >> 16) & 0xfff);
+                vcc_addr.usVci = (unsigned short) (be.has_vpiid & 0xffff);
+
+                brvcc->atm_num_tx_dps = 0;
+                vcc_cfg.ulStructureId = ID_ATM_VCC_CFG;
+                if( BcmAtm_GetVccCfg(&vcc_addr, &vcc_cfg) == STS_SUCCESS )
+                {
+                    if( vcc_cfg.ulTransmitQParmsSize == 0 )
+                        brvcc->atm_num_tx_dps = 80;
+                    else
+                    {
+                        for( i = 0; i < vcc_cfg.ulTransmitQParmsSize; i++ )
+                        {
+                            brvcc->atm_num_tx_dps +=
+                                vcc_cfg.TransmitQParms[i].ulSize;
+                        }
+                    }
+                }
+                else
+                    brvcc->atm_num_tx_dps = 80;
+
+                atm_tx_mem_size =  brvcc->atm_num_tx_dps *
+                    (sizeof(ATM_VCC_DATA_PARMS) + sizeof(ATM_BUFFER));
+                brvcc->atm_tx_mem = kmalloc(atm_tx_mem_size, GFP_KERNEL);
+                if( brvcc->atm_tx_mem != NULL )
+                {
+                    PATM_VCC_DATA_PARMS pDp;
+                    PATM_BUFFER pAb;
+
+                    memset(brvcc->atm_tx_mem, 0x00, atm_tx_mem_size); 
+                    INIT_LIST_HEAD(&brvcc->atm_list_tx_dps);
+
+                    for(i = 0, p = brvcc->atm_tx_mem; i < brvcc->atm_num_tx_dps;
+                        i++, p += sizeof(ATM_VCC_DATA_PARMS)+sizeof(ATM_BUFFER))
+                    {
+                        pDp = (PATM_VCC_DATA_PARMS) p;
+                        pAb = (PATM_BUFFER) (pDp + 1);
+
+                        pDp->ulStructureId = ID_ATM_VCC_DATA_PARMS;
+                        pDp->ucCircuitType = CT_AAL5;
+                        pDp->ucSendPriority = ANY_PRIORITY;
+                        pDp->pAtmBuffer = pAb;
+                        pDp->pFnFreeDataParms = br2684_free_dp;
+                        pDp->ulParmFreeDataParms = (UINT32) brvcc;
+
+                        list_add_tail((struct list_head *)
+                            pDp->ulApplicationDefined, &brvcc->atm_list_tx_dps);
+                    }
+
+                    /* Attach to VCC. */
+                    memset(&vcc_ap, 0x00, sizeof(vcc_ap));
+                    vcc_ap.ulStructureId = ID_ATM_VCC_ATTACH_PARMS;
+                    vcc_ap.pFnReceiveDataCb = (FN_RECEIVE_CB) br2684_rx_cb;
+                    vcc_ap.ulParmReceiveData = (unsigned long) brvcc;
+                    if( BcmAtm_AttachVcc( &vcc_addr, &vcc_ap ) == STS_SUCCESS )
+                        brvcc->atm_attach_handle = vcc_ap.ulHandle;
+                    else
+                    {
+                        kfree(brvcc->atm_tx_mem);
+                        brvcc->atm_tx_mem = NULL;
+
+                        ret = -EIO;
+                    }
+                }
+                else
+                    ret = -ENOMEM;
+            }
+            else
+            {
+                write_unlock_irq(&devs_lock);
+                printk(KERN_ERR
+                    "br2684: tried to attach to non-existant device\n");
+                ret = -ENXIO;
+            }
+        }
+        else
+            ret = -ENOMEM;
+    }
+    else
+        ret = -EFAULT;
+
+    DPRINTK("br2684_attachvcc retruns %d\n",ret);
+    return( ret );
+}
+
+/***************************************************************************
+ * Function Name: br2684_start_xmit
+ * Description  : Called by the Linux network stack to send a packet on an
+ *                ATM connection.  This function adds the RFC2684 header and
+ *                calls the Broadcom ATM driver function to send the packet.
+ * Returns      : Status.
+ ***************************************************************************/
+static int br2684_start_xmit_bcm(struct sk_buff *skb, struct net_device *dev)
+{
+    struct br2684_dev *brdev = BRPRIV(dev);
+    struct br2684_vcc *brvcc;
+#if defined(CONFIG_MIPS_BRCM)
+	struct net_devext *devext = EXTPRIV(dev);
+#endif
+
+    read_lock(&devs_lock_tx);
+
+    if( !list_empty(&brdev->brvccs) )
+    {
+        brvcc = list_entry_brvcc(brdev->brvccs.next);
+        
+        /* 
+         * Avoid transmission of non-pppoe packets on pppoe inteface
+         * when MSP enabled
+         */
+        if (((NULL == devext) && ((brvcc->proto_filter & FILTER_PPPOE)  == FILTER_PPPOE)) ||
+            ((NULL != devext) && ((devext->proto_filter & FILTER_PPPOE) == FILTER_PPPOE)))
+        {
+           unsigned short protocol;
+           if (skb->protocol == htons(ETH_P_8021Q))
+              protocol = *(unsigned short *)(&skb->data[VLAN_ETH_ALEN+VLAN_ETH_ALEN+VLAN_HLEN]);
+           else
+              protocol = skb->protocol;
+
+           if ((protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+           {
+               DPRINTK("non-PPPOE packet dropped on TX dev %s\n", dev->name);
+               dev_kfree_skb(skb);
+               read_unlock(&devs_lock);
+               return 0;
+           }
+        }
+
+        if( rfc2684OutMirrorStatus == MIRROR_ENABLED )
+            br2684_mirror_packet( skb, DIR_OUT, mirrorOutPort );
+
+        if (skb->len < MIN_PKT_SIZE)
+        {
+            struct sk_buff *skb2=skb_copy_expand(skb, 0, MIN_PKT_SIZE -
+                skb->len, GFP_ATOMIC);
+            dev_kfree_skb(skb);
+            if (skb2 == NULL)
+            {
+                brvcc->copies_failed++;
+                skb = NULL;
+            }
+            else
+            {
+                skb = skb2;
+                memset(skb->tail, 0, MIN_PKT_SIZE - skb->len);
+                skb_put(skb, MIN_PKT_SIZE - skb->len);
+            }
+        }
+
+         {
+            int minheadroom = (brvcc->encaps == e_llc) ? sizeof(llc_oui_pid_pad) : PADLEN;
+            int headroom = skb_headroom(skb);
+
+            if (headroom < minheadroom)
+            {
+                struct sk_buff *skb2 = skb_realloc_headroom(skb, minheadroom);
+
+                brvcc->copies_needed++;
+                DPRINTK("br2684_start_xmit_bcm realloc headroom %d < %d\n", \
+                    headroom, minheadroom);
+                dev_kfree_skb(skb);
+                if (skb2 == NULL)
+                {
+                    brvcc->copies_failed++;
+                    skb = NULL;
+                }
+                else
+                    skb = skb2;
+            }
+            if( skb )
+            {
+                int skblen;
+
+                skb_push(skb, minheadroom);
+                if( minheadroom == sizeof(llc_oui_pid_pad) )
+                    memcpy(skb->data, llc_oui_pid_pad, sizeof(llc_oui_pid_pad));
+                else
+                    skb->data[0] = skb->data[1] = 0x00;
+                skblen = skb->len;
+            }
+        }
+
+        if( skb )
+        {
+            int atmPriority = 0;
+            PATM_VCC_DATA_PARMS pDp;
+            PATM_BUFFER pAb;
+
+            if( !list_empty(&brvcc->atm_list_tx_dps) )
+            {
+#if defined(CONFIG_BCM96338) || defined(CONFIG_BCM96348) || defined(CONFIG_BCM96358)
+                /* If the buffer address is above 128MB, copy the buffer to a
+                 * new buffer that is below 128MB.
+                 */
+                const UINT32 ulHighAtmSarAddr = (128 * 1024 * 1024) - 2048;
+                if( ((UINT32) skb->data & ~0xe0000000) > ulHighAtmSarAddr )
+                {
+                    struct sk_buff *skb2=skb_copy(skb, GFP_ATOMIC | GFP_DMA); 
+                    if( skb2 )
+                    {
+                        dev_kfree_skb(skb);
+                        skb = skb2;
+                    }
+                    else
+                        printk("br2684: Unable to allocate buffer below 128MB\n");
+                }
+#endif
+
+                pDp = list_entry((void *) brvcc->atm_list_tx_dps.next, \
+                    ATM_VCC_DATA_PARMS, ulApplicationDefined);
+                list_del((struct list_head *) &pDp->ulApplicationDefined[0]);
+
+                pDp->ulApplicationDefined[0] = (UINT32) skb;
+                pDp->ulParmFreeDataParms = (UINT32) brvcc;
+                pAb = pDp->pAtmBuffer;
+                pAb->pDataBuf = skb->data;
+                pAb->ulDataLen = (UINT32) skb->len;
+
+#ifdef CONFIG_NETFILTER
+                atmPriority = skb->mark & 0x0F;
+                /* bit 3-0 of the 32-bit nfmark is the atm priority,
+                 *    set by iptables
+                 * bit 7-4 is the Ethernet switch physical port number,
+                 *    set by lan port drivers.
+                 * bit 8-10 is the wanVlan priority bits
+                 */
+                if (atmPriority <= 4 && atmPriority >= 1)
+                    pDp->ucSendPriority = atmPriority;
+                else if (skb->priority <= 4 && skb->priority >= 1)
+                    pDp->ucSendPriority = skb->priority;
+                else
+                    pDp->ucSendPriority = ANY_PRIORITY;
+#else
+                if (skb->priority <= 4 && skb->priority >= 1)
+                    pDp->ucSendPriority = skb->priority;
+                else
+                    pDp->ucSendPriority = ANY_PRIORITY;
+#endif
+
+                /* Send the data using the Broadcom ATM API. */
+                if( BcmAtm_SendVccData( brvcc->atm_attach_handle, pDp ) ==
+                    STS_SUCCESS )
+                {
+#if defined(CONFIG_MIPS_BRCM)
+                    if (devext) {
+        	                devext->stats.tx_packets++;
+    	                devext->stats.tx_bytes += skb->len;	    
+    	            }
+    	            else {
+    	                brdev->stats.tx_packets++;
+    	                brdev->stats.tx_bytes += skb->len;
+    	            }
+#else
+    	            brdev->stats.tx_packets++;
+    	            brdev->stats.tx_bytes += skb->len;
+#endif
+                }
+                else
+                {
+                    brdev->stats.tx_dropped++;
+                    dev_kfree_skb(skb);
+                    list_add_tail((struct list_head *)pDp->ulApplicationDefined,
+                        &brvcc->atm_list_tx_dps);
+                }
+            }
+            else
+            {
+                brdev->stats.tx_dropped++;
+                dev_kfree_skb(skb);
+            }
+        }
+    }
+    else
+    {
+        DPRINTK("no vcc attached to dev %s\n", dev->name);
+#if defined(CONFIG_MIPS_BRCM)
+        if (devext) {
+            devext->stats.tx_errors++;
+            devext->stats.tx_carrier_errors++;
+        } else {
+            brdev->stats.tx_errors++;
+            brdev->stats.tx_carrier_errors++;
+        }
+#else
+        brdev->stats.tx_errors++;
+        brdev->stats.tx_carrier_errors++;
+#endif
+        dev_kfree_skb(skb);
+    }
+
+    read_unlock(&devs_lock_tx);
+
+    return( 0 );
+}
+
+/***************************************************************************
+ * Function Name: br2684_free_dp
+ * Description  : Called by the Broadcom ATM driver after it has sent a
+ *                packet on an ATM PVC connection.
+ * Returns      : None.
+ ***************************************************************************/
+static void br2684_free_dp( PATM_VCC_DATA_PARMS pDp )
+{
+    struct sk_buff *skb = (struct skb *) pDp->ulApplicationDefined[0];
+    struct br2684_vcc *brvcc = (struct br2684_vcc *) pDp->ulParmFreeDataParms;
+
+    if( skb )
+        dev_kfree_skb_any( skb );
+
+    if( brvcc )
+    {
+        read_lock(&devs_lock_tx);
+        list_add_tail((struct list_head *) pDp->ulApplicationDefined,
+            &brvcc->atm_list_tx_dps);
+        read_unlock(&devs_lock_tx);
+    }
+}
+
+/***************************************************************************
+ * Function Name: br2684_rx_cb
+ * Description  : Called by the Broadcom ATM driver after it has received a
+ *                packet on an ATM PVC connection.
+ * Returns      : None.
+ ***************************************************************************/
+static void br2684_rx_cb( UINT32 ulHandle, PATM_VCC_ADDR pVccAddr,
+    PATM_VCC_DATA_PARMS pDp, struct br2684_vcc *brvcc )
+{
+   struct br2684_dev *brdev = BRPRIV(brvcc->device);
+   struct sk_buff *skb;
+   PATM_BUFFER pAb = pDp->pAtmBuffer;
+#if defined(CONFIG_MIPS_BRCM)
+   struct list_head *lh;
+   struct net_device * net_dev_ext;
+   unsigned char *dstAddr;
+   struct sk_buff * skb2;
+   int isPktTxed = 0;
+   struct net_devext *devext;
+   struct net_device * net_dev_match = NULL;
+#endif
+    
+
+   /* Remove RFC2684 header. */
+   unsigned long padlen = (brvcc->encaps == e_llc) ? sizeof(llc_oui_pid_pad) : PADLEN;
+   unsigned char *databuf = pAb->pDataBuf + padlen;
+   unsigned long datalen = pAb->ulDataLen - padlen;
+   unsigned long dataoffset = pAb->usDataOffset + padlen;
+   if (padlen == sizeof(llc_oui_pid_pad) && pAb->pDataBuf[7] == 0x01)
+      datalen -= 4; /* strip FCS */
+
+   read_lock(&devs_lock);
+
+   skb = g_free_atm_rx_skbs;
+   if (skb)
+   {
+      unsigned short protocol;
+
+      /* Get a socket buffer from the linked list of available skbs.*/
+      g_free_atm_rx_skbs = skb->retfreeq_context;
+      read_unlock(&devs_lock);
+
+#if !defined(ATM_CACHE_SMARTFLUSH)
+      skb_hdrinit(dataoffset, ETH_FRAME_LEN, skb, databuf,
+            (void *) br2684_free_skb_or_data, pDp, FROM_WAN);
+#else
+      skb_hdrinit(dataoffset, datalen+BR2684_SKB_TAILROOM, skb, databuf,
+            (void *) br2684_free_skb_or_data, pDp, FROM_WAN);
+#endif        
+
+      __skb_trim(skb, datalen);
+
+      if (rfc2684InMirrorStatus == MIRROR_ENABLED)
+         br2684_mirror_packet( skb, DIR_IN, mirrorInPort );
+
+      skb->dev = brvcc->device;
+      protocol = *(unsigned short *)(&skb->data[VLAN_ETH_ALEN+VLAN_ETH_ALEN+VLAN_HLEN]);
+      skb->protocol = eth_type_trans(skb, brvcc->device);
+
+      if (skb->protocol != htons(ETH_P_8021Q))
+         protocol = skb->protocol;
+
+      /* if MSP is not configured follow the old code path */
+      if (list_empty(&brdev->net_devexts))
+      {
+         /* no MSP here */
+         if (((brvcc->proto_filter & FILTER_PPPOE) == FILTER_PPPOE) &&
+             (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+         {
+            DPRINTK("non-PPPOE packet dropped on RX dev %s\n", brvcc->device->name);
+            dev_kfree_skb(skb);
+         }
+         else
+         {
+            brdev->stats.rx_packets++;
+            brdev->stats.rx_bytes += skb->len;
+            netif_rx(skb);
+         }
+      }   
+#if defined(CONFIG_MIPS_BRCM)
+      else
+      {
+         /* MSP */
+         isPktTxed = 0;
+         dstAddr = skb->mac.raw;
+
+         if (dstAddr[0] & 1)
+         {
+            /* multicast or broadcast frames */
+            list_for_each(lh, &brdev->net_devexts)
+            {
+               net_dev_ext = list_entry_devext(lh);
+               devext = EXTPRIV(net_dev_ext);
+               if (((NULL != devext) && ((devext->proto_filter & FILTER_PPPOE) == FILTER_PPPOE)) &&
+                   (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+               {
+                  DPRINTK("non-PPPOE packet dropped on RX dev %s\n", net_dev_ext->name);
+               }
+               else
+               {
+                  skb2 = skb_copy(skb, GFP_ATOMIC);
+                  skb2->dev = net_dev_ext;
+                  skb2->pkt_type = PACKET_HOST;
+                  devext->stats.rx_packets++;
+                  devext->stats.rx_bytes += skb->len; 
+                  netif_rx(skb2);
+               }
+            }
+
+            if (((brvcc->proto_filter & FILTER_PPPOE) == FILTER_PPPOE) &&
+                (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+            {
+               DPRINTK("non-PPPOE packet dropped on RX dev %s\n", brvcc->device->name);
+               dev_kfree_skb(skb);
+            }
+            else
+            {
+               brdev->stats.rx_packets++;
+               brdev->stats.rx_bytes += skb->len;
+               netif_rx(skb);
+            }
+            isPktTxed = 1;
+         }
+         else if (net_dev_match = bcm_match_route_interface(brdev, skb))
+         {
+            /* routing */
+            devext = EXTPRIV(net_dev_match);
+            if ((((NULL == devext) && ((brvcc->proto_filter  & FILTER_PPPOE) == FILTER_PPPOE)) ||
+                ((NULL != devext) && ((devext->proto_filter & FILTER_PPPOE) == FILTER_PPPOE))) &&
+               (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+            {
+               DPRINTK("non-PPPOE packet dropped on RX dev %s\n", net_dev_match->name);
+               dev_kfree_skb(skb);
+            }
+            else
+            {
+               if (skb->dev != net_dev_match)
+               {
+                  skb->dev = net_dev_match;
+                  skb->pkt_type = PACKET_HOST;
+                  devext->stats.rx_packets++;
+                  devext->stats.rx_bytes += skb->len; 
+               } 
+               else
+               {
+                  brdev->stats.rx_packets++;
+                  brdev->stats.rx_bytes += skb->len;
+               }
+               netif_rx(skb);
+            }
+            isPktTxed = 1;
+         }
+         else
+         {
+            /* bridging */
+            if (brvcc->device->promiscuity)
+            {
+               if (((brvcc->proto_filter & FILTER_PPPOE) == FILTER_PPPOE) &&
+                   (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+               {
+                  DPRINTK("non-PPPOE packet dropped on RX dev %s\n", brvcc->device->name);
+                  dev_kfree_skb(skb);
+               }
+               else
+               {
+                  brdev->stats.rx_packets++;
+                  brdev->stats.rx_bytes += skb->len;
+                  netif_rx(skb);
+               }
+               isPktTxed = 1;
+            }
+            else
+            {
+               list_for_each(lh, &brdev->net_devexts)
+               {
+                  net_dev_ext = list_entry_devext(lh);
+                  if (net_dev_ext->promiscuity)
+                  {
+                     devext = EXTPRIV(net_dev_ext);
+                     if (((NULL != devext) && ((devext->proto_filter & FILTER_PPPOE) == FILTER_PPPOE)) &&
+                         (protocol != htons(ETH_P_PPP_DISC)) && (protocol != htons(ETH_P_PPP_SES)))
+                     {
+                        DPRINTK("non-PPPOE packet dropped on RX dev %s\n", net_dev_ext->name);
+                        dev_kfree_skb(skb);
+                     }
+                     else
+                     {
+                        skb->dev =net_dev_ext; 
+                        skb->pkt_type = PACKET_HOST;
+                        devext->stats.rx_packets++;
+                        devext->stats.rx_bytes += skb->len; 
+                        netif_rx(skb);
+                     }
+                     isPktTxed = 1; 
+                     break;
+                  }
+               }
+            }
+         }
+
+         if (0 == isPktTxed)
+         {
+            DPRINTK("dropping packet that has wrong dest. on RX dev %s\n", brvcc->device->name);
+            dev_kfree_skb(skb);
+            brdev->stats.rx_dropped++;
+         }
+      }
+#endif
+   }
+   else
+   {
+      read_unlock(&devs_lock);
+      DPRINTK("br2684_rx_cb skb == NULL\n");
+      (*pDp->pFnFreeDataParms) (pDp);
+   }
+}
+
+/***************************************************************************
+ * Function Name: br2684_free_skb_or_data
+ * Description  : This callback function returns the socket buffer header or
+ *                socket buffer data that is no longer being used by the upper
+ *                network layers.
+ * Returns      : None.
+ ***************************************************************************/
+static void br2684_free_skb_or_data( PATM_VCC_DATA_PARMS pDp, void *pObj,
+    int nFlag )
+{
+    if( nFlag & RETFREEQ_SKB )
+    {
+        struct sk_buff *skb = (struct sk_buff *) pObj;
+
+        read_lock(&devs_lock);
+        skb->retfreeq_context = g_free_atm_rx_skbs;
+        g_free_atm_rx_skbs = skb;
+        read_unlock(&devs_lock);
+    }
+    else { /* free data */
+        (*pDp->pFnFreeDataParms)(pDp);
+    }    
+}
+
+/***************************************************************************
+ * Function Name: br2684_push_bcm
+ * Description  : This function should only be called when an ATM socket is
+ *                being closed. When this occurs, the socket buffer, skb,
+ *                will be NULL. It should never be called with a non-NULL skb.
+ * Returns      : None.
+ ***************************************************************************/
+static void br2684_push_bcm(struct atm_vcc *atmvcc, struct sk_buff *skb)
+{
+    struct br2684_vcc *brvcc = BR2684_VCC(atmvcc);
+    struct net_device *net_dev = brvcc->device;
+    struct br2684_dev *brdev = BRPRIV(net_dev);
+
+    if (likely(skb == NULL))
+    {
+        /* skb==NULL means VCC is being destroyed */
+        if( brvcc->atm_attach_handle )
+        {
+            BcmAtm_Detach( brvcc->atm_attach_handle );
+            brvcc->atm_attach_handle = 0;
+        }
+
+        br2684_close_vcc(brvcc);
+
+        if (list_empty(&brdev->brvccs))
+        {
+            read_lock(&devs_lock);
+            list_del(&brdev->br2684_devs);
+            read_unlock(&devs_lock);
+            unregister_netdev(net_dev);
+            free_netdev(net_dev);
+        }
+    }
+    else
+    {
+        /* This should not happen. */
+        printk("br2684: br2684_push_bcm called with non-NULL skb\n");
+        dev_kfree_skb(skb);
+    }
+}
+
+/***************************************************************************
+ * Function Name: br2684_mirror_packet
+ * Description  : This function sends a sent or received packet to a LAN port.
+ *                The purpose is to allow packets sent and received on the WAN
+ *                to be captured by a protocol analyzer on the Lan for debugging
+ *                purposes.
+ * Returns      : None.
+ ***************************************************************************/
+void br2684_mirror_packet( struct sk_buff *pSockBuf, UINT32 dir, char *dev )
+{
+    struct sk_buff *pCloneBuf;
+    struct net_device *netDev;
+
+    if( (pCloneBuf = skb_clone(pSockBuf, GFP_ATOMIC)) != NULL )
+    {
+        if( (netDev = __dev_get_by_name(dev)) != NULL )
+        {
+            unsigned long flags;
+
+            pCloneBuf->dev = netDev;
+            pCloneBuf->protocol = htons(ETH_P_802_3);
+            local_irq_save(flags);
+            local_irq_enable();
+            dev_queue_xmit(pCloneBuf) ;
+            local_irq_restore(flags);
+        }
+        else
+            dev_kfree_skb(pCloneBuf);
+    }
+}
+/***************************************************************************
+ * Function Name: bcm_set_proto_filter
+ * Description  : set the pppoe filter for non-primary service
+ *               
+ * Returns      : Status.
+ ***************************************************************************/
+static int bcm_set_proto_filter(struct atm_vcc *atmvcc, void __user *arg)
+{
+    int ret = 0;
+    struct br2684_dev *brdev;
+    struct net_device *net_dev;
+    struct atm_backend_br2684 be;
+    struct net_devext *devext;
+    struct net_device * net_dev_ext;
+    struct list_head *lh;
+    char if_name[16];
+
+    if( copy_from_user(&be, arg, sizeof be) == 0 )
+    {
+	read_lock(&devs_lock);
+        net_dev = br2684_find_dev(&be.ifspec);
+        if( net_dev )
+        {
+            sprintf(if_name, "%s_%d",be.ifspec.spec.ifname, be.extif);
+            brdev = BRPRIV(net_dev);
+            list_for_each(lh, &brdev->net_devexts) {
+                net_dev_ext = list_entry_devext(lh);
+                devext = EXTPRIV(net_dev_ext);
+                    
+                if((be.extif) && (0 == strcmp(if_name, net_dev_ext->name)))
+                   devext->proto_filter |= be.proto_filter;
+           }
+         }
+         else
+         {
+                printk(KERN_ERR
+                    "br2684: tried to configure on non-existant device\n");
+                ret = -ENXIO;
+         }
+         read_unlock(&devs_lock);
+    }
+    else
+        ret = -EFAULT;
+
+    DPRINTK("bcm_set_proto_filter %d\n",ret);
+    return( ret );
+}
+
+#if 0
+/***************************************************************************
+ * Function Name: bcm_is_pppoe_passthrough_pkt
+ * Description  : checks if the packet is pppoe passthrough by checking 
+ *                all MAC addresses
+ *               
+ * Returns      : 0 if it is pppoe passthrough
+ ***************************************************************************/
+static int bcm_is_pppoe_passthrough_pkt(struct br2684_dev *brdev, 
+     struct sk_buff *skb, struct net_device **net_dev)
+{
+    int ret = -1;
+    unsigned char *dstAddr;
+    struct net_devext *devext;
+    struct net_device *net_dev_ext;
+    struct list_head *lh;
+    
+    *net_dev = NULL;
+#if 0 // Pavan
+    dstAddr = skb->mac.ethernet->h_dest;
+#endif
+#if 1 // Pavan
+    dstAddr = skb->mac.raw;
+#endif
+    
+    if(!memcmp(dstAddr, skb->dev->dev_addr, ETH_ALEN)) {
+        *net_dev = skb->dev;
+    } 
+    else {
+        list_for_each(lh, &brdev->net_devexts) {
+            net_dev_ext = list_entry_devext(lh);
+            devext = EXTPRIV(net_dev_ext);
+            if(!memcmp(dstAddr, net_dev_ext->dev_addr, ETH_ALEN)) {
+                *net_dev = net_dev_ext;
+                 break;
+            }
+        }
+    }
+    
+    if((NULL == *net_dev) && ((htons(ETH_P_PPP_DISC) == skb->protocol) ||
+                              (htons(ETH_P_PPP_SES) == skb->protocol))) {
+        ret = 0;
+    }
+
+    return( ret );
+}
+#endif
+
+/***************************************************************************
+ * Function Name: bcm_match_route_interface
+ * Description  : check the frame's destination MAC address against each
+ *                interfaces to see if it is destined to a route interface.
+ *               
+ * Returns      : the route interface or NULL if it is a bridge frame.
+ ***************************************************************************/
+static struct net_device *bcm_match_route_interface(struct br2684_dev *brdev, struct sk_buff *skb)
+{
+   unsigned char *dstAddr;
+   struct net_devext *devext;
+   struct net_device *net_dev = NULL;
+   struct net_device *net_dev_ext;
+   struct list_head  *lh;
+    
+   dstAddr = skb->mac.raw;
+    
+   if (!memcmp(dstAddr, skb->dev->dev_addr, ETH_ALEN)) {
+      net_dev = skb->dev;
+   } 
+   else {
+      list_for_each(lh, &brdev->net_devexts) {
+         net_dev_ext = list_entry_devext(lh);
+         devext = EXTPRIV(net_dev_ext);
+         if (!memcmp(dstAddr, net_dev_ext->dev_addr, ETH_ALEN)) {
+            net_dev = net_dev_ext;
+            break;
+         }
+      }
+   }
+   return (net_dev);
+}
+#endif
+
+
 module_init(br2684_init);
 module_exit(br2684_exit);
 
diff --exclude=.svn -pNur linux-2.6.21.7/net/atm/common.c linux-2.6.21.7/net/atm/common.c
--- linux-2.6.21.7/net/atm/common.c	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/net/atm/common.c	2008-10-13 18:23:39.000000000 +0200
@@ -40,6 +40,11 @@
 struct hlist_head vcc_hash[VCC_HTABLE_SIZE];
 DEFINE_RWLOCK(vcc_sklist_lock);
 
+#if defined(CONFIG_MIPS_BRCM) && defined(CONFIG_BCM_VDSL)
+int g_nPtmTraffic = 0;
+EXPORT_SYMBOL(g_nPtmTraffic);
+#endif
+
 static void __vcc_insert_socket(struct sock *sk)
 {
 	struct atm_vcc *vcc = atm_sk(sk);
@@ -260,6 +265,13 @@ static int adjust_tp(struct atm_trafprm 
 			    "(%d)\n",aal);
 			/* fall through */
 		case ATM_AAL5:
+#if defined(CONFIG_MIPS_BRCM)
+			/* Use a big max sdu within Linux.  It will be verified by the
+			 * Broadcom ATM driver.
+			 */
+		case ATM_AAL2:
+		case ATM_BCM_AAL0:
+#endif		
 			max_sdu = ATM_MAX_AAL5_PDU;
 	}
 	if (!tp->max_sdu) tp->max_sdu = max_sdu;
@@ -382,6 +394,13 @@ static int __vcc_connect(struct atm_vcc 
 			vcc->qos.aal = ATM_AAL5;
 			/* fall through */
 		case ATM_AAL5:
+#if defined(CONFIG_MIPS_BRCM)
+			/* All aal types must call atm_init_aal5 so that send packets go to
+			 * the Broadcom blaa driver.
+			 */
+		case ATM_AAL2:
+		case ATM_BCM_AAL0:
+#endif		
 			error = atm_init_aal5(vcc);
 			vcc->stats = &dev->stats.aal5;
 			break;
@@ -433,6 +452,18 @@ int vcc_connect(struct socket *sock, int
 	else
 		if (test_bit(ATM_VF_PARTIAL,&vcc->flags))
 			return -EINVAL;
+#if defined(CONFIG_MIPS_BRCM)
+	DPRINTK("vcc_connect (TX: cl %d,bw %d-%d,sdu %d; "
+	    "RX: cl %d,bw %d-%d,sdu %d,AAL %s%d)\n",
+	    vcc->qos.txtp.traffic_class,vcc->qos.txtp.min_pcr,
+	    vcc->qos.txtp.max_pcr,vcc->qos.txtp.max_sdu,
+	    vcc->qos.rxtp.traffic_class,vcc->qos.rxtp.min_pcr,
+	    vcc->qos.rxtp.max_pcr,vcc->qos.rxtp.max_sdu,
+	    vcc->qos.aal == ATM_AAL5 ? "" : (vcc->qos.aal == ATM_AAL0 ||
+	    vcc->qos.aal == ATM_BCM_AAL0) ? "" : " ??? code ",
+		(vcc->qos.aal == ATM_AAL0 || vcc->qos.aal == ATM_BCM_AAL0) ? 0
+	    : vcc->qos.aal);
+#else	
 	DPRINTK("vcc_connect (TX: cl %d,bw %d-%d,sdu %d; "
 	    "RX: cl %d,bw %d-%d,sdu %d,AAL %s%d)\n",
 	    vcc->qos.txtp.traffic_class,vcc->qos.txtp.min_pcr,
@@ -441,6 +472,7 @@ int vcc_connect(struct socket *sock, int
 	    vcc->qos.rxtp.max_pcr,vcc->qos.rxtp.max_sdu,
 	    vcc->qos.aal == ATM_AAL5 ? "" : vcc->qos.aal == ATM_AAL0 ? "" :
 	    " ??? code ",vcc->qos.aal == ATM_AAL0 ? 0 : vcc->qos.aal);
+#endif	    
 	if (!test_bit(ATM_VF_HASQOS, &vcc->flags))
 		return -EBADFD;
 	if (vcc->qos.txtp.traffic_class == ATM_ANYCLASS ||
diff --exclude=.svn -pNur linux-2.6.21.7/net/atm/Kconfig linux-2.6.21.7/net/atm/Kconfig
--- linux-2.6.21.7/net/atm/Kconfig	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/net/atm/Kconfig	2008-10-13 18:23:39.000000000 +0200
@@ -72,3 +72,13 @@ config ATM_BR2684_IPFILTER
 	  This is an experimental mechanism for users who need to terminate a
 	  large number of IP-only vcc's.  Do not enable this unless you are sure
 	  you know what you are doing.
+
+# CONFIG_MIPS_BRCM Begin Broadcom added code.
+config ATM_RT2684
+	tristate "RFC1483/2684 Routed protocols"
+	depends on ATM && INET
+	help
+	  ATM PVCs can carry PPP PDUs according to RFC2364. This is a simplified
+	  point-to-point PPPoA implementation without atmarp support.
+# CONFIG_MIPS_BRCM End Broadcom added code.
+	  
diff --exclude=.svn -pNur linux-2.6.21.7/net/atm/Makefile linux-2.6.21.7/net/atm/Makefile
--- linux-2.6.21.7/net/atm/Makefile	2007-08-04 18:11:13.000000000 +0200
+++ linux-2.6.21.7/net/atm/Makefile	2008-10-13 18:23:39.000000000 +0200
@@ -1,13 +1,23 @@
 #
 # Makefile for the ATM Protocol Families.
 #
+ifneq ($(strip $(BUILD_BRCM_VLAN)),)
+CFLAGS	+= -DSUPPORT_VLAN
+endif
 
 atm-y		:= addr.o pvc.o signaling.o svc.o ioctl.o common.o atm_misc.o raw.o resources.o atm_sysfs.o
 mpoa-objs	:= mpc.o mpoa_caches.o mpoa_proc.o
 
 obj-$(CONFIG_ATM) += atm.o
 obj-$(CONFIG_ATM_CLIP) += clip.o
+atm-$(subst m,y,$(CONFIG_ATM_CLIP)) += ipcommon.o
 obj-$(CONFIG_ATM_BR2684) += br2684.o
+atm-$(subst m,y,$(CONFIG_ATM_BR2684)) += ipcommon.o
+atm-$(subst m,y,$(CONFIG_NET_SCH_ATM)) += ipcommon.o
+# CONFIG_MIPS_BRCM Begin Broadcom added code.
+obj-$(CONFIG_ATM_RT2684) += rt2684.o
+atm-$(subst m,y,$(CONFIG_ATM_RT2684)) += ipcommon.o
+# CONFIG_MIPS_BRCM End Broadcom added code.
 atm-$(CONFIG_PROC_FS) += proc.o
 
 obj-$(CONFIG_ATM_LANE) += lec.o
